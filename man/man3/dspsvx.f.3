.TH "dspsvx.f" 3 "Sat Nov 16 2013" "Version 3.4.2" "LAPACK" \" -*- nroff -*-
.ad l
.nh
.SH NAME
dspsvx.f \- 
.SH SYNOPSIS
.br
.PP
.SS "Functions/Subroutines"

.in +1c
.ti -1c
.RI "subroutine \fBdspsvx\fP (FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR, WORK, IWORK, INFO)"
.br
.RI "\fI\fB DSPSVX computes the solution to system of linear equations A * X = B for OTHER matrices\fP \fP"
.in -1c
.SH "Function/Subroutine Documentation"
.PP 
.SS "subroutine dspsvx (characterFACT, characterUPLO, integerN, integerNRHS, double precision, dimension( * )AP, double precision, dimension( * )AFP, integer, dimension( * )IPIV, double precision, dimension( ldb, * )B, integerLDB, double precision, dimension( ldx, * )X, integerLDX, double precisionRCOND, double precision, dimension( * )FERR, double precision, dimension( * )BERR, double precision, dimension( * )WORK, integer, dimension( * )IWORK, integerINFO)"

.PP
\fB DSPSVX computes the solution to system of linear equations A * X = B for OTHER matrices\fP  
.PP
\fBPurpose: \fP
.RS 4

.PP
.nf
 DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
 A = L*D*L**T to compute the solution to a real system of linear
 equations A * X = B, where A is an N-by-N symmetric matrix stored
 in packed format and X and B are N-by-NRHS matrices.

 Error bounds on the solution and a condition estimate are also
 provided.
.fi
.PP
 
.RE
.PP
\fBDescription: \fP
.RS 4

.PP
.nf
 The following steps are performed:

 1. If FACT = 'N', the diagonal pivoting method is used to factor A as
       A = U * D * U**T,  if UPLO = 'U', or
       A = L * D * L**T,  if UPLO = 'L',
    where U (or L) is a product of permutation and unit upper (lower)
    triangular matrices and D is symmetric and block diagonal with
    1-by-1 and 2-by-2 diagonal blocks.

 2. If some D(i,i)=0, so that D is exactly singular, then the routine
    returns with INFO = i. Otherwise, the factored form of A is used
    to estimate the condition number of the matrix A.  If the
    reciprocal of the condition number is less than machine precision,
    INFO = N+1 is returned as a warning, but the routine still goes on
    to solve for X and compute error bounds as described below.

 3. The system of equations is solved for X using the factored form
    of A.

 4. Iterative refinement is applied to improve the computed solution
    matrix and calculate error bounds and backward error estimates
    for it.
.fi
.PP
 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIFACT\fP 
.PP
.nf
          FACT is CHARACTER*1
          Specifies whether or not the factored form of A has been
          supplied on entry.
          = 'F':  On entry, AFP and IPIV contain the factored form of
                  A.  AP, AFP and IPIV will not be modified.
          = 'N':  The matrix A will be copied to AFP and factored.
.fi
.PP
.br
\fIUPLO\fP 
.PP
.nf
          UPLO is CHARACTER*1
          = 'U':  Upper triangle of A is stored;
          = 'L':  Lower triangle of A is stored.
.fi
.PP
.br
\fIN\fP 
.PP
.nf
          N is INTEGER
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0.
.fi
.PP
.br
\fINRHS\fP 
.PP
.nf
          NRHS is INTEGER
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0.
.fi
.PP
.br
\fIAP\fP 
.PP
.nf
          AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
          The upper or lower triangle of the symmetric matrix A, packed
          columnwise in a linear array.  The j-th column of A is stored
          in the array AP as follows:
          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
          See below for further details.
.fi
.PP
.br
\fIAFP\fP 
.PP
.nf
          AFP is DOUBLE PRECISION array, dimension
                            (N*(N+1)/2)
          If FACT = 'F', then AFP is an input argument and on entry
          contains the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as
          a packed triangular matrix in the same storage format as A.

          If FACT = 'N', then AFP is an output argument and on exit
          contains the block diagonal matrix D and the multipliers used
          to obtain the factor U or L from the factorization
          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as
          a packed triangular matrix in the same storage format as A.
.fi
.PP
.br
\fIIPIV\fP 
.PP
.nf
          IPIV is INTEGER array, dimension (N)
          If FACT = 'F', then IPIV is an input argument and on entry
          contains details of the interchanges and the block structure
          of D, as determined by DSPTRF.
          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
          interchanged and D(k,k) is a 1-by-1 diagonal block.
          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

          If FACT = 'N', then IPIV is an output argument and on exit
          contains details of the interchanges and the block structure
          of D, as determined by DSPTRF.
.fi
.PP
.br
\fIB\fP 
.PP
.nf
          B is DOUBLE PRECISION array, dimension (LDB,NRHS)
          The N-by-NRHS right hand side matrix B.
.fi
.PP
.br
\fILDB\fP 
.PP
.nf
          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,N).
.fi
.PP
.br
\fIX\fP 
.PP
.nf
          X is DOUBLE PRECISION array, dimension (LDX,NRHS)
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
.fi
.PP
.br
\fILDX\fP 
.PP
.nf
          LDX is INTEGER
          The leading dimension of the array X.  LDX >= max(1,N).
.fi
.PP
.br
\fIRCOND\fP 
.PP
.nf
          RCOND is DOUBLE PRECISION
          The estimate of the reciprocal condition number of the matrix
          A.  If RCOND is less than the machine precision (in
          particular, if RCOND = 0), the matrix is singular to working
          precision.  This condition is indicated by a return code of
          INFO > 0.
.fi
.PP
.br
\fIFERR\fP 
.PP
.nf
          FERR is DOUBLE PRECISION array, dimension (NRHS)
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error.
.fi
.PP
.br
\fIBERR\fP 
.PP
.nf
          BERR is DOUBLE PRECISION array, dimension (NRHS)
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution).
.fi
.PP
.br
\fIWORK\fP 
.PP
.nf
          WORK is DOUBLE PRECISION array, dimension (3*N)
.fi
.PP
.br
\fIIWORK\fP 
.PP
.nf
          IWORK is INTEGER array, dimension (N)
.fi
.PP
.br
\fIINFO\fP 
.PP
.nf
          INFO is INTEGER
          = 0: successful exit
          < 0: if INFO = -i, the i-th argument had an illegal value
          > 0:  if INFO = i, and i is
                <= N:  D(i,i) is exactly zero.  The factorization
                       has been completed but the factor D is exactly
                       singular, so the solution and error bounds could
                       not be computed. RCOND = 0 is returned.
                = N+1: D is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest.
.fi
.PP
 
.RE
.PP
\fBAuthor:\fP
.RS 4
Univ\&. of Tennessee 
.PP
Univ\&. of California Berkeley 
.PP
Univ\&. of Colorado Denver 
.PP
NAG Ltd\&. 
.RE
.PP
\fBDate:\fP
.RS 4
April 2012 
.RE
.PP
\fBFurther Details: \fP
.RS 4

.PP
.nf
  The packed storage scheme is illustrated by the following example
  when N = 4, UPLO = 'U':

  Two-dimensional storage of the symmetric matrix A:

     a11 a12 a13 a14
         a22 a23 a24
             a33 a34     (aij = aji)
                 a44

  Packed storage of the upper triangle of A:

  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
.fi
.PP
 
.RE
.PP

.PP
Definition at line 277 of file dspsvx\&.f\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LAPACK from the source code\&.
